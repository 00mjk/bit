package git_extras

const GitEffort = "#!/usr/bin/env bash\n\ntmp=$(git_extra_mktemp)\nabove=0\n# if the output won't be printed to tty, disable the color\ntest -t 1 && to_tty=true\ncolor=\n\n#\n# print usage message\n#\nusage() {\n  echo 1>&2 \"usage: git effort [--above <value>] [<path>...] [-- [<log options>...]]\"\n}\n\n#\n# get dates for the given <commit>\n#\ndates() {\n  eval \"git log $args_to_git_log --pretty='format: %ad' --date=short -- \\\"$1\\\"\"\n}\n\n# tput, being quiet about unknown capabilities\ntputq() {\n  tput \"$@\" 2>/dev/null\n  return 0\n}\n\n#\n# hide cursor\n#\n\nhide_cursor() {\n  tputq civis\n}\n\n#\n# show cursor, and remove temporary file\n#\n\nshow_cursor_and_cleanup() {\n  tputq cnorm\n  tputq sgr0\n  rm \"$tmp\" > /dev/null 2>&1\n  exit 0\n}\n\n#\n# get active days for the given <commit>\n#\n\nactive_days() {\n  echo \"$1\" | sort -r | uniq | wc -l\n}\n\n#\n# set 'color' based on the given <num>\n#\n\ncolor_for() {\n  if [ \"$to_tty\" = true ]; then\n    if   [ $1 -gt 200 ]; then color=\"$(tputq setaf 1)$(tputq bold)\"\n    elif [ $1 -gt 150 ]; then color=\"$(tputq setaf 1)\"  # red\n    elif [ $1 -gt 125 ]; then color=\"$(tputq setaf 2)$(tputq bold)\"\n    elif [ $1 -gt 100 ]; then color=\"$(tputq setaf 2)\"  # green\n    elif [ $1 -gt 75 ]; then color=\"$(tputq setaf 5)$(tputq bold)\"\n    elif [ $1 -gt 50 ]; then color=\"$(tputq setaf 5)\"  # purplish\n    elif [ $1 -gt 25 ]; then color=\"$(tputq setaf 3)$(tputq bold)\"\n    elif [ $1 -gt 10 ]; then color=\"$(tputq setaf 3)\"  # yellow\n    else color=\"$(tputq sgr0)\" # default color\n    fi\n  else\n    color=\"\"\n  fi\n}\n\n#\n# compute the effort of the given <path ...>\n#\n\neffort() {\n    path=$1\n    local commit_dates\n    local color reset_color commits len dot f_dot i msg active\n    reset_color=\"\"\n    test \"$to_tty\" = true && reset_color=\"$(tputq sgr0)\"\n    commit_dates=`dates \"$path\"`\n    [ $? -gt 0 ] && exit 255\n\n    # Ensure it's not just an empty line\n    if [ -z \"`head -c 1 <<<$(echo $commit_dates)`\" ]\n    then\n      exit 0\n    fi\n\n    commits=`wc -l <<<\"$(echo \"$commit_dates\")\"`\n    color='90'\n\n    # ignore <= --above\n    test $commits -le $above && exit 0\n\n    # commits\n    color_for $(( $commits - $above ))\n    len=${#path}\n    dot=\".\"\n    f_dot=\"$path\"\n    i=0 ; while test $i -lt $(( $columns - $len )) ; do\n      f_dot=$f_dot$dot\n      i=$(($i+1))\n    done\n\n    msg=$(printf \"  ${color}%s %-10d\" \"$f_dot\" $commits)\n\n    # active days\n    active=`active_days \"$commit_dates\"`\n    color_for $(( $active - $above ))\n    msg=\"$msg $(printf \"${color} %d${reset_color}\\n\" $active)\"\n    echo \"$msg\"\n}\n\n#\n# print heading\n#\n\nheading() {\n  echo\n  printf \"  %-${columns}s %-10s %s\\n\" 'path' 'commits' 'active days'\n  echo\n}\n\n#\n# output sorted results\n#\n\nsort_effort() {\n  clear\n  echo \" \"\n  heading\n  < $tmp sort -rn -k 2\n}\n\ndeclare -a paths=()\nwhile [ \"${#}\" -ge 1 ] ; do\n\n  case \"$1\" in\n    --above)\n      shift\n      above=$1\n      ;;\n    --)\n      shift\n      args_to_git_log=$(printf \" %q\" \"${@:1}\")\n      break\n      ;;\n    --*)\n      usage\n      echo 1>&2 \"error: unknown argument $1\"\n      echo 1>&2 \"error: if that argument was meant for git-log,\"\n      echo 1>&2 \"error: please put it after two dashes ( -- ).\"\n      exit 1\n      ;;\n    *)\n      paths+=( \"$1\" )\n      ;;\n  esac\n\n  shift\ndone\n\n# Exit if above-value is not an int\nif [ -z \"${above##*[!0-9]*}\" ] ; then\n  echo \"error: argument to --above was not an integer\" 1>&2\n  exit 1\nfi\n\n# remove empty quotes that appear when there are no arguments\nargs_to_git_log=\"${args_to_git_log#\\ \\'\\'}\"\nexport args_to_git_log\n\n# [path ...]\n\nif test \"${#paths}\" -eq 0; then\n  save_ifs=$IFS\n  IFS=`echo -en \"\\n\\b\"`\n  paths=(`git ls-files`)\n  IFS=$save_ifs\n  unset save_ifs\nfi\n\n# set column width to match longest filename\nmax=0\nfor path in \"${paths[@]}\"; do\n    cur=${#path}\n    if [[ $max -lt $cur ]]; then\n        max=$cur\n    fi\ndone\ncolumns=$(( max + 5 ))\nexport columns\n\n# hide cursor\n\nhide_cursor\ntrap show_cursor_and_cleanup INT\n\n# export functions so subshells can call them\nexport -f effort\nexport -f color_for\nexport -f active_days\nexport -f dates\nexport -f tputq\nexport to_tty\nexport above\nexport log_args\n\n\nbash_params=\n# If bash exits successfully with --import-functions,\n# then we need to pass it (FreeBSD probably)\nbash --import-functions -c \":\" 1>/dev/null 2>&1\nif [ $? -eq 0 ] ; then\n  bash_params=\"--import-functions\"\nfi\n\nheading\n# send paths to effort\nprintf \"%s\\0\" \"${paths[@]}\" | xargs -0 -n 1 -P 4 -I % bash $bash_params -c \"effort \\\"%\\\"\" | tee $tmp\n\n# if more than one path, sort and print\ntest \"$(wc -l $tmp | awk '{print $1}')\" -gt 1 && sort_effort\necho\n\nshow_cursor_and_cleanup"
